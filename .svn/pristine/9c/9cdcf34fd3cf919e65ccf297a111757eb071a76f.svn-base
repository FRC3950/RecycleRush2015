// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.




#include "DriveSubsystem.h"

#include <math.h>

#include "../RobotMap.h"
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include "../Commands/DriveCommand.h"
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

#include "../UtilFun.h"
#include "../Logger.h"
#include "../LoggingComponentDefs.h"
#include "../ConfigKeys.h"
#include "../Config/ConfigInstanceMgr.h"

static double CalcPercentageOfMaxSpeed(double absoluteDistanceFromGoal,
									   double absoluteGoalDistance,
									   double absoluteSlowDownThresholdDistance);

static const float TWIST_TOLERANCE_MIN_DEFAULT = -0.33;
static const float TWIST_TOLERANCE_MAX_DEFAULT = 0.33;
static const float TWIST_SCALE_FACTOR_DEFAULT = 0.65;

static const float Y_TOLERANCE_MIN_DEFAULT = -0.25;
static const float Y_TOLERANCE_MAX_DEFAULT = 0.25;

static const float X_TOLERANCE_MIN_DEFAULT = -0.25;
static const float X_TOLERANCE_MAX_DEFAULT = 0.35;

static bool Drive_Params_Inited = false;

static float Twist_Tolerance_Min = -0.33;
static float Twist_Tolerance_Max = 0.33;
static float Twist_Scale_Factor = 0.65;

static float X_Scale_Factor = 1.0;
static float Y_Scale_Factor = 1.0;
static float Slow_Down_Scaling_Factor = 0.5;

static float X_Scale_Factor_Default = 1.0;
static float Y_Scale_Factor_Default = 1.0;
static float Slow_Down_Scaling_Factor_Default = 0.5;

static float Y_Tolerance_Min = -0.25;
static float Y_Tolerance_Max = 0.25;

static float X_Tolerance_Min = -0.25;
static float X_Tolerance_Max = 0.35;

// Diameter of the robot's wheels in inches.
static const int WHEEL_DIAMETER_IN_INCHES_DEFAULT = 8;
static int WheelDiameterInInches = WHEEL_DIAMETER_IN_INCHES_DEFAULT;

// Circumference of the wheel;
static double WheelCircumference = M_PI * WheelDiameterInInches;

// Number of counts per shaft rotation.
static const int COUNTS_PER_SHAFT_ROTATION_DEFAULT = 1000;
static int CountsPerShaftRotation = COUNTS_PER_SHAFT_ROTATION_DEFAULT;

// Max speed to use when doing an Automatic Rotation.
static const float AUTO_ROTATE_MAX_SPEED_DEFAULT = 1.0;
static float AutoRotateMaxSpeed = AUTO_ROTATE_MAX_SPEED_DEFAULT;

// This constant is used as the threshold to begin slowing down the robot
// when it is auto-rotating and there is 45 degrees or less to go in the
// rotation.  This should be made a configuration value.
static const float AUTO_ROTATE_SLOW_DOWN_THRESHOLD_DEFAULT = 45;
static float AutoRotateSlowDownThreshold = AUTO_ROTATE_SLOW_DOWN_THRESHOLD_DEFAULT;

// Precision to use for rotation angles.
static const float ANGLE_DECIMAL_PLACES_PRECISION_DEFAULT = 100.00;
static float AngleDecimalPlacesPrecision = ANGLE_DECIMAL_PLACES_PRECISION_DEFAULT;

// Epsilon to use to figure out if close enough to the rotation target.
static const float AUTO_ROTATE_TARGET_ANGLE_EPSILON_DEFAULT = 2.0;
static float AutoRotate_TargetAngle_Epsilon = AUTO_ROTATE_TARGET_ANGLE_EPSILON_DEFAULT;


// When true uses one motor to determine whether auto driving distance has
// been met.  When false all four must have driven the driving distance.
static const bool AUTO_DRIVE_USE_ONE_MOTOR_FOR_DISTANCE_DRIVE_DEFAULT = true;
static bool AutoDriveUseOneMotorForDistanceDrive = AUTO_DRIVE_USE_ONE_MOTOR_FOR_DISTANCE_DRIVE_DEFAULT;

// Scaling factor to use when performing and AutoDrive in the forward/back direction.
static const float AUTO_DRIVE_FORWARD_BACK_HEADING_SPEED_SCALE_FACTOR_DEFAULT = 1.0;
static float AutoDriveForwardBackHeadingSpeedScaleFactor = AUTO_DRIVE_FORWARD_BACK_HEADING_SPEED_SCALE_FACTOR_DEFAULT;

// Scaling factor to use when performing and AutoDrive in the left/right direction.
static const float AUTO_DRIVE_LEFT_RIGHT_HEADING_SPEED_SCALE_FACTOR_DEFAULT = 1.0;
static float AutoDriveLeftRightHeadingSpeedScaleFactor = AUTO_DRIVE_LEFT_RIGHT_HEADING_SPEED_SCALE_FACTOR_DEFAULT;

// This constant is used as the threshold to begin slowing down the robot
// when it is auto-driving and there is 24 inches or less to go in the
// auto-drive.  This should be made a configuration value.
static const float AUTO_DRIVE_SLOW_DOWN_THRESHOLD_IN_INCHES_DEFAULT = 24.0;
static float AutoDriveSlowDownThresholdInInches = AUTO_DRIVE_SLOW_DOWN_THRESHOLD_IN_INCHES_DEFAULT;

static float AutoDriveSlowDownThresholdInShaftRotations = -1.0;

// Epsilon to use to figure out if close enough to the auto-drive target.
static const float AUTO_DRIVE_TARGET_DISTANCE_EPSILON_IN_INCHES_DEFAULT = 2.0;
static float AutoDriveTargetDistanceEpsilonInInches = AUTO_DRIVE_TARGET_DISTANCE_EPSILON_IN_INCHES_DEFAULT;

static float AutoDriveTargetDistanceEpsilonInCounts = -1.0;

static const bool DRIVE_SAFETY_ENABLED_DEFAULT = false;
static const float DRIVE_SAFETY_TIME_OUT_DEFAULT = 1.0;

static const float AUTO_DRIVE_FRONT_LEFT_SPEED_DEFAULT = 0.75;
static float AutoDriveFrontLeftMotorSpeed = AUTO_DRIVE_FRONT_LEFT_SPEED_DEFAULT;

static const float AUTO_DRIVE_FRONT_RIGHT_SPEED_DEFAULT = 0.75;
static float AutoDriveFrontRightMotorSpeed = AUTO_DRIVE_FRONT_RIGHT_SPEED_DEFAULT;

static const float AUTO_DRIVE_BACK_LEFT_SPEED_DEFAULT = 0.75;
static float AutoDriveBackLeftMotorSpeed = AUTO_DRIVE_BACK_LEFT_SPEED_DEFAULT;

static const float AUTO_DRIVE_BACK_RIGHT_SPEED_DEFAULT = 0.75;
static float AutoDriveBackRightMotorSpeed = AUTO_DRIVE_BACK_RIGHT_SPEED_DEFAULT;

static const std::string ForwardHeading = "Forward";
static const std::string BackHeading = "Back";
static const std::string LeftHeading = "Left";
static const std::string RightHeading = "Right";
static const std::string IllegalHeading = "Illegal Heading";

static const std::string LeftDirection = "RotateLeft";
static const std::string RightDirection = "RotateRight";
static const std::string IllegalDirection = "Illegal Direction";

static const std::string AutoModeOff = "Off";
static const std::string AutoModeDriving = "Driving";
static const std::string AutoModeRotating = "Rotating";
static const std::string IllegalAutoMode = "Illegal Auto Mode";


static const bool DriveHeadingValid(DriveHeading heading) {
	switch (heading) {
	case DriveForward:
	case DriveBack:
	case DriveLeft:
	case DriveRight:
		return true;

	default:
		return false;
	}
}

static const bool RotateDirectionValid(RotateDirection direction) {
	switch (direction) {

	case RotateLeft:
	case RotateRight:
		return true;

	default:
		return false;
	}
}

static const double LateralDistanceMultipler = 1.0;

static const double CountsPerInch = 80.9;
static const double ShaftCountErrorFactor = 344.1;

static double DistanceToShaftRotationCount(int distanceToTravelInInches, DriveHeading heading)
{
	if (distanceToTravelInInches <= 0.0)
	{
		return 0.0;
	}

	/*
	double shaftRotationCountTarget = distanceToTravelInInches / WheelCircumference;
	shaftRotationCountTarget *= CountsPerShaftRotation;
	*/

	double shaftRotationCountTarget = (CountsPerInch * distanceToTravelInInches) - ShaftCountErrorFactor;

	if ((heading == DriveLeft) || (heading == DriveRight))
	{
		shaftRotationCountTarget *= LateralDistanceMultipler;
	}

	return shaftRotationCountTarget;
}

static void InitDriveSubsystemConfiguration()
{
    ConfigMgr *configMgr = ConfigInstanceMgr::getInstance();

    if (!Drive_Params_Inited) {
    	X_Tolerance_Min = configMgr->getDoubleVal(ConfigKeys::Drive_XToleranceMin,X_TOLERANCE_MIN_DEFAULT);

    	X_Tolerance_Max = configMgr->getDoubleVal(ConfigKeys::Drive_XToleranceMax,X_TOLERANCE_MAX_DEFAULT);

    	Y_Tolerance_Min = configMgr->getDoubleVal(ConfigKeys::Drive_YToleranceMin,Y_TOLERANCE_MIN_DEFAULT);

    	Y_Tolerance_Max = configMgr->getDoubleVal(ConfigKeys::Drive_YToleranceMax,Y_TOLERANCE_MAX_DEFAULT);

    	Twist_Tolerance_Min = configMgr->getDoubleVal(ConfigKeys::Drive_TwistToleranceMin,TWIST_TOLERANCE_MIN_DEFAULT);

    	Twist_Tolerance_Max = configMgr->getDoubleVal(ConfigKeys::Drive_TwistToleranceMax,TWIST_TOLERANCE_MAX_DEFAULT);

    	Twist_Scale_Factor = configMgr->getDoubleVal(ConfigKeys::Drive_TwistScaleFactor,TWIST_SCALE_FACTOR_DEFAULT);

    	X_Scale_Factor = configMgr->getDoubleVal(ConfigKeys::Drive_XScaleFactor,X_Scale_Factor_Default);

    	Y_Scale_Factor = configMgr->getDoubleVal(ConfigKeys::Drive_YScaleFactor,Y_Scale_Factor_Default);

    	Slow_Down_Scaling_Factor = configMgr->getDoubleVal(ConfigKeys::Drive_SlowDownScaleFactor,Slow_Down_Scaling_Factor_Default);

    	WheelDiameterInInches = configMgr->getDoubleVal(ConfigKeys::Drive_WheelDiameterInInchesKey, WHEEL_DIAMETER_IN_INCHES_DEFAULT);
    	WheelCircumference = M_PI * WheelDiameterInInches;

    	CountsPerShaftRotation = configMgr->getDoubleVal(ConfigKeys::Drive_CountsPerShaftRotationKey, COUNTS_PER_SHAFT_ROTATION_DEFAULT);

		AutoRotateMaxSpeed = static_cast<float>(configMgr->getDoubleVal(ConfigKeys::Drive_AutoRotateMaxSpeedKey, AUTO_ROTATE_MAX_SPEED_DEFAULT));

		AutoRotateSlowDownThreshold = static_cast<float>(configMgr->getDoubleVal(ConfigKeys::Drive_AutoRotateSlowDownThresholdKey, AUTO_ROTATE_SLOW_DOWN_THRESHOLD_DEFAULT));

		AngleDecimalPlacesPrecision = static_cast<float>(configMgr->getDoubleVal(ConfigKeys::Drive_AngleDecimalPlacesPrecisionKey, ANGLE_DECIMAL_PLACES_PRECISION_DEFAULT));

		AutoRotate_TargetAngle_Epsilon = static_cast<float>(configMgr->getDoubleVal(ConfigKeys::Drive_AutoRotateTargetAngleEpsilonKey, AUTO_ROTATE_TARGET_ANGLE_EPSILON_DEFAULT));

		AutoDriveUseOneMotorForDistanceDrive = configMgr->getBoolVal(ConfigKeys::Drive_AutoDriveUseOneMotorForDistanceDriveKey, AUTO_DRIVE_USE_ONE_MOTOR_FOR_DISTANCE_DRIVE_DEFAULT);

		AutoDriveForwardBackHeadingSpeedScaleFactor = static_cast<float>(configMgr->getDoubleVal(ConfigKeys::Drive_AutoDriveFowardBackHeadingSpeedScaleFactorKey, AUTO_DRIVE_FORWARD_BACK_HEADING_SPEED_SCALE_FACTOR_DEFAULT));

		AutoDriveLeftRightHeadingSpeedScaleFactor = static_cast<float>(configMgr->getDoubleVal(ConfigKeys::Drive_AutoDriveLeftRightHeadingSpeedScaleFactorKey, AUTO_DRIVE_LEFT_RIGHT_HEADING_SPEED_SCALE_FACTOR_DEFAULT));

		AutoDriveSlowDownThresholdInInches = static_cast<float>(configMgr->getDoubleVal(ConfigKeys::Drive_AutoDriveSlowDownThresholdInInchesKey, AUTO_DRIVE_SLOW_DOWN_THRESHOLD_IN_INCHES_DEFAULT));

		AutoDriveSlowDownThresholdInShaftRotations = DistanceToShaftRotationCount(AutoDriveSlowDownThresholdInInches, DriveForward);

		AutoDriveTargetDistanceEpsilonInInches = static_cast<float>(configMgr->getDoubleVal(ConfigKeys::Drive_AutoDriveTargetDistanceEpsilonInInchesKey, AUTO_DRIVE_TARGET_DISTANCE_EPSILON_IN_INCHES_DEFAULT));

		AutoDriveTargetDistanceEpsilonInCounts = DistanceToShaftRotationCount(AutoDriveTargetDistanceEpsilonInInches, DriveForward);

		AutoDriveFrontLeftMotorSpeed = configMgr->getDoubleVal(ConfigKeys::Drive_AutoDriveFrontLeftSpeedKey, AUTO_DRIVE_FRONT_LEFT_SPEED_DEFAULT);

		AutoDriveFrontRightMotorSpeed = configMgr->getDoubleVal(ConfigKeys::Drive_AutoDriveFrontRightSpeedKey, AUTO_DRIVE_FRONT_RIGHT_SPEED_DEFAULT);

		AutoDriveBackLeftMotorSpeed = configMgr->getDoubleVal(ConfigKeys::Drive_AutoDriveBackLeftSpeedKey, AUTO_DRIVE_BACK_LEFT_SPEED_DEFAULT);

		AutoDriveBackRightMotorSpeed = configMgr->getDoubleVal(ConfigKeys::Drive_AutoDriveBackRightSpeedKey, AUTO_DRIVE_BACK_RIGHT_SPEED_DEFAULT);


		Logger* logger = Logger::GetInstance();

		logger->Log(DriveSubsystemLogId,Logger::kINFO, "DriveSubsystem: X Tolerance min = %f, max = %f\n", X_Tolerance_Min, X_Tolerance_Max);
		logger->Log(DriveSubsystemLogId,Logger::kINFO, "DriveSubsystem: Y Tolerance min = %f, max = %f\n", Y_Tolerance_Min, Y_Tolerance_Max);
		logger->Log(DriveSubsystemLogId,Logger::kINFO, "DriveSubsystem: Twist Tolerance min = %f, max = %f, Scale factor = %f \n", Twist_Tolerance_Min, Twist_Tolerance_Max, Twist_Scale_Factor);

		logger->Log(DriveSubsystemLogId,Logger::kINFO, "DriveSubsystem: Wheel Diameter = %d inches\n", WheelDiameterInInches);
		logger->Log(DriveSubsystemLogId,Logger::kINFO, "DriveSubsystem: Counts Per Shaft Rotation = %d inches\n", CountsPerShaftRotation);

		logger->Log(DriveSubsystemLogId,Logger::kINFO, "DriveSubsystem: Wheel Diameter = %d inches, Circumference = %g\n",
      				WheelDiameterInInches, WheelCircumference);

		logger->Log(DriveSubsystemLogId, Logger::kINFO, "DriveSubsystem: AutoRotateMaxSpeed = %f\n", AutoRotateMaxSpeed);
		logger->Log(DriveSubsystemLogId, Logger::kINFO, "DriveSubsystem: AutoRotateAnglePrecision = %f\n", AngleDecimalPlacesPrecision);
		logger->Log(DriveSubsystemLogId, Logger::kINFO, "DriveSubsystem: AutoRotateTargetAngleEpsilon = %f\n", AutoRotate_TargetAngle_Epsilon);

		logger->Log(DriveSubsystemLogId, Logger::kINFO, "DriveSubsystem: AutoDriveForwardBackHeadingSpeedScaleFactor = %f\n", AutoDriveForwardBackHeadingSpeedScaleFactor);
		logger->Log(DriveSubsystemLogId, Logger::kINFO, "DriveSubsystem: AutoDriveLeftRightHeadingMaxSpeed = %f\n", AutoDriveLeftRightHeadingSpeedScaleFactor);

		logger->Log(DriveSubsystemLogId, Logger::kINFO, "DriveSubsystem: AutoDriveSlowDownThresholdInInches = %f\n", AutoDriveSlowDownThresholdInInches);
		logger->Log(DriveSubsystemLogId, Logger::kINFO, "DriveSubsystem: AutoDriveSlowDownThresholdInShaftRotations = %f\n", AutoDriveSlowDownThresholdInShaftRotations);
		logger->Log(DriveSubsystemLogId, Logger::kINFO, "DriveSubsystem: AutoDriveTargetDistanceEpsilonInInches = %f\n", AutoDriveTargetDistanceEpsilonInInches);
		logger->Log(DriveSubsystemLogId, Logger::kINFO, "DriveSubsystem: AutoDriveTargetDistanceEpsilonInCounts = %f\n", AutoDriveTargetDistanceEpsilonInCounts);

		logger->Log(DriveSubsystemLogId, Logger::kINFO, "DriveSubsystem: SlowDownScalingFactor = %f\n", Slow_Down_Scaling_Factor);
		logger->Log(DriveSubsystemLogId, Logger::kINFO, "DriveSubsystem: XScalingFactor = %f\n", X_Scale_Factor);
		logger->Log(DriveSubsystemLogId, Logger::kINFO, "DriveSubsystem: YScalingFactor = %f\n", Y_Scale_Factor);

      	Drive_Params_Inited = true;
    }
}

const std::string& DriveHeadingToString(DriveHeading heading) {
	switch (heading) {
	case DriveForward:
		return ForwardHeading;

	case DriveBack:
		return BackHeading;

	case DriveLeft:
		return LeftHeading;

	case DriveRight:
		return RightHeading;

	default:
		return IllegalHeading;
	}

}

const std::string& RotateDirectionToString(RotateDirection direction) {
	switch (direction) {

	case RotateLeft:
		return LeftDirection;

	case RotateRight:
		return RightDirection;

	default:
		return IllegalDirection;
	}
}

const std::string& AutoModeToString(AutoMode mode) {
	switch (mode) {
	case Off:
		return AutoModeOff;

	case Driving:
		return AutoModeDriving;

	case Rotating:
		return AutoModeRotating;

	default:
		return IllegalAutoMode;
	}
}

// *********************************************************************************
// V a r i o u s  M o d e s  of the  T a l o n   M o t o r
// This sets the mode of the m_motor. The options are:
// kPercentVbus: basic throttle; no closed-loop.
// kCurrent: Runs the motor with the specified current if possible.
// kSpeed: Runs a PID control loop to keep the motor going at a constant
//   speed using the specified sensor.
// kPosition: Runs a PID control loop to move the motor to a specified move
//   the motor to a specified sensor position.
// kVoltage: Runs the m_motor at a constant voltage, if possible.
// kFollower: The m_motor will run at the same throttle as the specified other talon.
//m_motor.SetControlMode(CANSpeedController::kPosition);
// This command allows you to specify which feedback device to use when doing
// closed-loop control. The options are:
// AnalogPot: Basic analog potentiometer
// QuadEncoder: Quadrature Encoder
// AnalogEncoder: Analog Encoder
// EncRising: Counts the rising edges of the QuadA pin (allows use of a
//   non-quadrature encoder)
// EncFalling: Same as EncRising, but counts on falling edges.
// m_motor.SetFeedbackDevice(CANTalon::AnalogPot);
// This sets the basic P, I , and D values (F, Izone, and rampRate can also
//   be set, but are ignored here).
// These must all be positive floating point numbers (SetSensorDirection will
//   multiply the sensor values by negative one in case your sensor is flipped
//   relative to your motor).
// These values are in units of throttle / sensor_units where throttle ranges
//   from -1023 to +1023 and sensor units are from 0 - 1023 for analog
//   potentiometers, encoder ticks for encoders, and position / 10ms for
//   speeds.
// m_motor.SetPID(1.0, 0.0, 0.0);
// *********************************************************************************

DriveSubsystem::DriveSubsystem() : Subsystem("DriveSubsystem") {
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	cANTalon1 = RobotMap::driveSubsystemCANTalon1;
	cANTalon3 = RobotMap::driveSubsystemCANTalon3;
	cANTalon2 = RobotMap::driveSubsystemCANTalon2;
	cANTalon4 = RobotMap::driveSubsystemCANTalon4;
	robotDrive = RobotMap::driveSubsystemRobotDrive;
	gyro1 = RobotMap::driveSubsystemGyro1;
	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

	autoMode = Off;
	autoActionState = NotStarted;

    ConfigMgr *configMgr = ConfigInstanceMgr::getInstance();

    if (!Drive_Params_Inited) {
    	InitDriveSubsystemConfiguration();
    }

	if (gyro1)
	{
	    useGyro = configMgr->getBoolVal(ConfigKeys::Drive_UseGyroKey, DriveSubsystemConfigValueDefaults::Drive_UseGyroDefaultValue);
	}
	else
	{
		useGyro = false;
	}

	Logger::GetInstance()->Log(DriveSubsystemLogId, Logger::kINFO, "DriveSubsystem: Gyro created=<%s>, UseGyro=<%s>\n",
							   gyro1 ? "TRUE" : "FALSE",
							   useGyro ? "TRUE" : "FALSE");

	cANTalon1->SetControlMode(CANTalon::kPercentVbus);
	cANTalon3->SetControlMode(CANTalon::kPercentVbus);
	cANTalon2->SetControlMode(CANTalon::kPercentVbus);
	cANTalon4->SetControlMode(CANTalon::kPercentVbus);
}
    
void DriveSubsystem::InitDefaultCommand() {
	// Set the default command for a subsystem here.
	//SetDefaultCommand(new MySpecialCommand());
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	SetDefaultCommand(new DriveCommand());
	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}


// Put methods for controlling this subsystem
// here. Call these from Commands.

void DriveSubsystem::MecanumDrive(float x, float y, float twist, bool slowMode) {
	float gyroAngle = 0.0;

	// Only attempt to use the gyro if it has been created
	// and the configuration says to use it.
	if (gyro1 && useGyro)
	{
		gyroAngle = gyro1->GetAngle();
	}

	//filter the X Y and twist values to 0 if they are in a min max tolerence range
	// otherwise the original value is used

	x = ZeroIfInRangeInclusive(x, X_Tolerance_Min,X_Tolerance_Max);
	y = ZeroIfInRangeInclusive(y,Y_Tolerance_Min,Y_Tolerance_Max);
	twist = ZeroIfInRangeInclusive(twist,Twist_Tolerance_Min,Twist_Tolerance_Max);

	float currScaleFactor = 1.0;

	if (slowMode) {
		currScaleFactor = Slow_Down_Scaling_Factor;
	}

	x *= X_Scale_Factor * currScaleFactor;
	y *= Y_Scale_Factor * currScaleFactor;

	//Scale twist so movements are smoother.
	twist *= Twist_Scale_Factor * currScaleFactor;

	Logger::GetInstance()->Log(DriveSubsystemLogId,Logger::kINFO, "DriveSubsystem:Filtered(x,y,twist,angle)=(%f, %f, %f, %f)\n", x, y, twist, gyroAngle);

	robotDrive->MecanumDrive_Cartesian(x, y, twist, gyroAngle);

	//robotDriveMecanum->ArcadeDrive(y,twist);
}

void DriveSubsystem::EnableDriveSubsystem() {
	 ConfigMgr *configMgr = ConfigInstanceMgr::getInstance();

	 float expiration = 0.0;
	 bool enable = configMgr->getBoolVal(ConfigKeys::Drive_EnableSafety, DRIVE_SAFETY_ENABLED_DEFAULT);

	 if (enable)
	 {
		 expiration = configMgr->getDoubleVal(ConfigKeys::Drive_SafetyTimeOut, DRIVE_SAFETY_TIME_OUT_DEFAULT);
	 }

	Logger::GetInstance()->Log(DriveSubsystemLogId,Logger::kINFO, "DriveSubsystem:EnableDriveSubsystem() ->SafetyEnable=%s, timeout=%f\n",
			enable ? "TRUE" : "FALSE",
			expiration);

	SetSafetyMode(cANTalon1, enable, expiration);
	SetSafetyMode(cANTalon2, enable, expiration);
	SetSafetyMode(cANTalon3, enable, expiration);
	SetSafetyMode(cANTalon4, enable, expiration);
	robotDrive->SetSafetyEnabled(enable);

	if (enable)
	{
		robotDrive->SetSafetyEnabled(expiration);
	}

	cANTalon1->EnableControl();
	cANTalon2->EnableControl();
	cANTalon3->EnableControl();
	cANTalon4->EnableControl();


	cANTalon1->Set(0);
	cANTalon2->Set(0);
	cANTalon3->Set(0);
	cANTalon4->Set(0);

	if (gyro1 && useGyro)
	{
		gyro1->Reset();
	}
}

void DriveSubsystem::SetSafetyMode(CANTalon* motor, bool enabled, float timeout) {
	motor->SetSafetyEnabled(enabled);
	motor->SetExpiration(timeout);
}

bool DriveSubsystem::AutoDriveSetup(DriveHeading heading, float distance)

{
	return AutoDriveSetup(heading, distance, 1.0);
}

bool DriveSubsystem::AutoDriveSetup(DriveHeading heading, float distance, double speedScaleFactor)
{
	if (autoMode == Off) {
		if (DriveHeadingValid(heading) && (distance > 0.0) && (speedScaleFactor > 0.0))
		{
			autoMode = Driving;
			autoActionState = NotStarted;
			autoDrivingParams.autoHeading = heading;
			autoDrivingParams.autoDriveDistanceInInches = distance;
			autoDrivingParams.totalRotationsToDesiredPosition = DistanceToShaftRotationCount(distance, heading);
			autoDrivingParams.speedScaleFactor = speedScaleFactor;

			Logger::GetInstance()->Log(DriveSubsystemLogId,Logger::kINFO,"Auto Drive Mode ENABLED, heading = %s, distance = %f inches, %g rotations, speed scale factor = %f\n",
									   DriveHeadingToString(autoDrivingParams.autoHeading).c_str(),
									   autoDrivingParams.autoDriveDistanceInInches,
									   autoDrivingParams.totalRotationsToDesiredPosition,
									   autoDrivingParams.speedScaleFactor);
			return true;
		}
		else{
			Logger::GetInstance()->Log(DriveSubsystemLogId, Logger::kERROR,"Auto Drive Mode NOT ENABLED, illegal heading = %s, distance = %f inches or speed scaling factor = %f\n",
									   DriveHeadingToString(autoDrivingParams.autoHeading).c_str(),
									   autoDrivingParams.autoDriveDistanceInInches,
									   speedScaleFactor);
		}
	}
	else {
		Logger::GetInstance()->Log(DriveSubsystemLogId,Logger::kERROR,"***Auto Drive Mode ALREADY set to %s, IGNNORING***\n", AutoModeToString(autoMode).c_str());
	}

	return false;
}

void DriveSubsystem::AutoDriveExecute()
{
	if (autoMode == Driving) {

		if (autoActionState == Completed)
		{
			return;
		}

		double distanceTraveledSoFar[4];

		if (autoActionState == NotStarted) {
			// Indicate that the rotation is now in progress.
			autoActionState = InProgress;

			// here is where we would start the PID or the manual encoder code
			SetMotorSpeeds(0.0);
			cANTalon1->SetPosition(0.0);
			cANTalon2->SetPosition(0.0);
			cANTalon3->SetPosition(0.0);
			cANTalon4->SetPosition(0.0);
			Wait(0.100);

			AutoDriveReadMotorRotationCounts();

			autoDrivingParams.positionCountAtStartOfAutoDrive[0] = autoDrivingParams.lastPositionReading[0];
			autoDrivingParams.lastDistanceFromGoal[0] = autoDrivingParams.totalRotationsToDesiredPosition - (autoDrivingParams.lastPositionReading[0] - autoDrivingParams.positionCountAtStartOfAutoDrive[0]);

			if (!AutoDriveUseOneMotorForDistanceDrive)
			{
				autoDrivingParams.positionCountAtStartOfAutoDrive[1] = autoDrivingParams.lastPositionReading[1];
				autoDrivingParams.positionCountAtStartOfAutoDrive[2] = autoDrivingParams.lastPositionReading[2];
				autoDrivingParams.positionCountAtStartOfAutoDrive[3] = autoDrivingParams.lastPositionReading[3];

				autoDrivingParams.lastDistanceFromGoal[1] = autoDrivingParams.totalRotationsToDesiredPosition - (autoDrivingParams.lastPositionReading[1] - autoDrivingParams.positionCountAtStartOfAutoDrive[1]);
				autoDrivingParams.lastDistanceFromGoal[2] = autoDrivingParams.totalRotationsToDesiredPosition - (autoDrivingParams.lastPositionReading[2] - autoDrivingParams.positionCountAtStartOfAutoDrive[2]);
				autoDrivingParams.lastDistanceFromGoal[3] = autoDrivingParams.totalRotationsToDesiredPosition - (autoDrivingParams.lastPositionReading[3] - autoDrivingParams.positionCountAtStartOfAutoDrive[3]);
			}

			distanceTraveledSoFar[0] = 0.0;
			distanceTraveledSoFar[1] = 0.0;
			distanceTraveledSoFar[2] = 0.0;
			distanceTraveledSoFar[3] = 0.0;

			Logger::GetInstance()->Log(DriveSubsystemLogId,Logger::kINFO,"AutoDriveExecute: Switching to InProgress, (position, lastPostion)=%g, lastDistance=%gMode\n",
									   autoDrivingParams.lastPositionReading[0],
									   autoDrivingParams.lastDistanceFromGoal[0]);
		}
		else {
			AutoDriveReadMotorRotationCounts();

			distanceTraveledSoFar[0] = autoDrivingParams.lastPositionReading[0] - autoDrivingParams.positionCountAtStartOfAutoDrive[0];


			Logger::GetInstance()->Log(DriveSubsystemLogId,Logger::kINFO,"AutoDriveExecute: InProgress, lastPostion=%g, distanceSoFar=%g, prevDistance=%g\n",
									   autoDrivingParams.lastPositionReading[0],
									   distanceTraveledSoFar[0],
									   autoDrivingParams.lastDistanceFromGoal[0]);

			if (!AutoDriveUseOneMotorForDistanceDrive)
			{
				distanceTraveledSoFar[1] = autoDrivingParams.lastPositionReading[1] - autoDrivingParams.positionCountAtStartOfAutoDrive[1];
				distanceTraveledSoFar[2] = autoDrivingParams.lastPositionReading[2] - autoDrivingParams.positionCountAtStartOfAutoDrive[2];
				distanceTraveledSoFar[3] = autoDrivingParams.lastPositionReading[3] - autoDrivingParams.positionCountAtStartOfAutoDrive[3];
			}
		}

		AutoDriveMakeProgress(distanceTraveledSoFar);
	}
	else {
		Logger::GetInstance()->Log(DriveSubsystemLogId,Logger::kERROR,"***Auto Driving not setup or already Auto Driving (%s), IGNNORING***\n", AutoModeToString(autoMode).c_str());
	}
}

void DriveSubsystem::AutoDriveMakeProgress(double distanceTraveledSoFar[]) {
	//RotateDirection being a new enum with just left and right
	// or we can find the shortest distance by comparing the
	if (autoMode == Driving)
	{
		Logger::GetInstance()->Log(DriveSubsystemLogId, Logger::kTRACE, "AutoDriveMakeProgress:: Step 1");
		if (autoActionState == InProgress)
		{
			double distanceFromGoal[4];

			AutoDriveCalcDistanceFromGoal(distanceTraveledSoFar, distanceFromGoal);

			Logger::GetInstance()->Log(DriveSubsystemLogId, Logger::kTRACE, "AutoDriveMakeProgress:: Step 2");

			// If the distance from the goal is NOT within the epsilon AND
			// if the distance from the targeted distance has not grown
			// since the last distance calculation apply voltage.
			if (!AutoDriveShouldStop(distanceFromGoal)) {

				Logger::GetInstance()->Log(DriveSubsystemLogId, Logger::kTRACE, "AutoDriveMakeProgress:: Step 3");

				// Calculate the speed that the Robot should start rotating at.

				/*
				float percentageOfMaxSpeed = CalcPercentageOfMaxSpeed(distanceFromGoal,
																	  autoDrivingParams.totalRotationsToDesiredPosition,
																	  AutoDriveSlowDownThresholdInShaftRotations);
				*/

				if ((autoDrivingParams.autoHeading == DriveForward) || (autoDrivingParams.autoHeading == DriveBack))
				{
					AutoDriveFrontLeftMotorSpeed *= AutoDriveForwardBackHeadingSpeedScaleFactor * autoDrivingParams.speedScaleFactor;
					AutoDriveBackLeftMotorSpeed *= AutoDriveForwardBackHeadingSpeedScaleFactor * autoDrivingParams.speedScaleFactor;
					AutoDriveFrontRightMotorSpeed *= AutoDriveForwardBackHeadingSpeedScaleFactor * autoDrivingParams.speedScaleFactor;
					AutoDriveBackRightMotorSpeed *= AutoDriveForwardBackHeadingSpeedScaleFactor * autoDrivingParams.speedScaleFactor;
				}
				else
				{
					AutoDriveFrontLeftMotorSpeed *= AutoDriveLeftRightHeadingSpeedScaleFactor * autoDrivingParams.speedScaleFactor;
					AutoDriveBackLeftMotorSpeed *= AutoDriveLeftRightHeadingSpeedScaleFactor * autoDrivingParams.speedScaleFactor;
					AutoDriveFrontRightMotorSpeed *= AutoDriveLeftRightHeadingSpeedScaleFactor * autoDrivingParams.speedScaleFactor;
					AutoDriveBackRightMotorSpeed *= AutoDriveLeftRightHeadingSpeedScaleFactor * autoDrivingParams.speedScaleFactor;
				}

				Logger::GetInstance()->Log(DriveSubsystemLogId, Logger::kINFO,"AutoDriveMakeProgress: InProgress, distanceFromGoal=%g, distanceSoFar=%g, absFrontLeftSpeed=%f, absBackLeftSpeed=%f, absFrontRightSpeed=%f, absBackRightSpeed=%f\n",
										   distanceFromGoal[0],
										   distanceTraveledSoFar[0],
										   AutoDriveFrontLeftMotorSpeed,
										   AutoDriveBackLeftMotorSpeed,
										   AutoDriveFrontRightMotorSpeed,
										   AutoDriveBackRightMotorSpeed);

				switch (autoDrivingParams.autoHeading)
				{
				case DriveForward:
					Logger::GetInstance()->Log(DriveSubsystemLogId, Logger::kINFO,"AutoDriveMakeProgress: Heading Forward\n");
					SetMotorSpeeds(-AutoDriveFrontLeftMotorSpeed,
								   -AutoDriveBackLeftMotorSpeed,
								   AutoDriveFrontRightMotorSpeed,
								   AutoDriveBackRightMotorSpeed);
					break;

				case DriveBack:
					Logger::GetInstance()->Log(DriveSubsystemLogId, Logger::kINFO,"AutoDriveMakeProgress: Heading Backward\n");
					SetMotorSpeeds(AutoDriveFrontLeftMotorSpeed,
								   AutoDriveBackLeftMotorSpeed,
								  -AutoDriveFrontRightMotorSpeed,
								  -AutoDriveBackRightMotorSpeed);
					break;

				case DriveLeft:
					Logger::GetInstance()->Log(DriveSubsystemLogId, Logger::kINFO,"AutoDriveMakeProgress: Heading Left\n");
					SetMotorSpeeds(AutoDriveFrontLeftMotorSpeed,
								   -AutoDriveBackLeftMotorSpeed,
								   AutoDriveFrontRightMotorSpeed,
								   -AutoDriveBackRightMotorSpeed);
					break;

				case DriveRight:
					Logger::GetInstance()->Log(DriveSubsystemLogId, Logger::kINFO,"AutoDriveMakeProgress: Heading Right\n");
					SetMotorSpeeds(-AutoDriveFrontLeftMotorSpeed,
									AutoDriveBackLeftMotorSpeed,
								   -AutoDriveFrontRightMotorSpeed,
								   AutoDriveBackRightMotorSpeed);
					break;
				}
			}
			else {
				// Hit the stopping point, shutdown.
				SetMotorSpeeds(0.0);
				autoActionState = Completed;

				Logger::GetInstance()->Log(DriveSubsystemLogId, Logger::kINFO,"AutoDriveMakeProgress: InProgress, Stopping Motors\n");
			}
		}
	}
	else {
		Logger::GetInstance()->Log(DriveSubsystemLogId,Logger::kERROR,"***Auto Rotation not setup or already Rotating (%s), IGNNORING***\n", AutoModeToString(autoMode).c_str());
	}
}

void DriveSubsystem::AutoDriveCalcDistanceFromGoal(double distanceTraveledSoFar[],
												   double distanceResult[]) const
{
	Logger::GetInstance()->Log(DriveSubsystemLogId, Logger::kTRACE, "AutoDriveCalcDistanceFromGoal:: Step 1");

	distanceResult[0] = autoDrivingParams.totalRotationsToDesiredPosition - distanceTraveledSoFar[0];

	Logger::GetInstance()->Log(DriveSubsystemLogId, Logger::kTRACE, "AutoDriveCalcDistanceFromGoal:: Step 2");

	if (!AutoDriveUseOneMotorForDistanceDrive)
	{
		distanceResult[1] = autoDrivingParams.totalRotationsToDesiredPosition - distanceTraveledSoFar[1];
		distanceResult[2] = autoDrivingParams.totalRotationsToDesiredPosition - distanceTraveledSoFar[2];
		distanceResult[3] = autoDrivingParams.totalRotationsToDesiredPosition - distanceTraveledSoFar[3];
	}

	Logger::GetInstance()->Log(DriveSubsystemLogId, Logger::kTRACE, "AutoDriveCalcDistanceFromGoal:: Step 3");

}

bool DriveSubsystem::AutoDriveShouldStop(double distanceFromGoal[]) const
{
	Logger::GetInstance()->Log(DriveSubsystemLogId, Logger::kTRACE, "AutoDriveShouldStop:: Step 1");

	if (AutoDriveUseOneMotorForDistanceDrive)
	{
		Logger::GetInstance()->Log(DriveSubsystemLogId, Logger::kTRACE, "AutoDriveShouldStop:: Step 2 - One Motor.");
		bool result = (distanceFromGoal[0] <= 0) || (distanceFromGoal[0] > autoDrivingParams.lastDistanceFromGoal[0]);

		Logger::GetInstance()->Log(DriveSubsystemLogId, Logger::kINFO, "AutoDriveShouldStop:: distanceFromGoal[0]=%g, lastDistanceFromGoal[0]=%g,stopping=%s\n",
								   distanceFromGoal[0], autoDrivingParams.lastDistanceFromGoal[0], result ? "TRUE" : "FALSE");

		Logger::GetInstance()->Log(DriveSubsystemLogId, Logger::kTRACE, "AutoDriveShouldStop:: Step 3 - One Motor.");

		return result;
	}

	// Check all four motors.
	for (int i = 0; i < 4; ++i)
	{
		Logger::GetInstance()->Log(DriveSubsystemLogId, Logger::kTRACE, "AutoDriveShouldStop:: Motor%d - distanceFromGoal=%g, lastDistanceFromGoal=%g\n",
								   i, distanceFromGoal[i], autoDrivingParams.lastDistanceFromGoal[i]);

		// If the current motor hasn't reached its goal, then don't stop unless...
		if (distanceFromGoal[i] > 0)
		{
			// Before returning that it is safe to continue driving, Check all
			// the Talons that have a non-zero distance to travel, that they've
			// actually made progress on the distance they need to close.  If
			// any one of them has not, stop.
			/*
			for (int i2 = 0; i < 4; ++i2)
			{
				if ((distanceFromGoal[i2]  0) && (distanceFromGoal[i2] > autoDrivingParams.lastDistanceFromGoal[i2]))
				{
					Logger::GetInstance()->Log(DriveSubsystemLogId, Logger::kINFO, "AutoDriveShouldStop:: STOPPING because of INCREASING DISTANCE: Motor%d - distanceFromGoal=%g, lastDistanceFromGoal=%g\n",
											   i2, distanceFromGoal[i2], autoDrivingParams.lastDistanceFromGoal[i2]);

					return true;
				}
			}
			*/

			Logger::GetInstance()->Log(DriveSubsystemLogId, Logger::kINFO, "AutoDriveShouldStop:: NOT STOPPING: Motor%d has distance=%g to go.\n",
									   i, distanceFromGoal[i]);

			return false;
		}
	}

	Logger::GetInstance()->Log(DriveSubsystemLogId, Logger::kINFO, "AutoDriveShouldStop:: STOPPING: All Motors Have Reached Goal Distance.\n");

	return true;
}

bool DriveSubsystem::AutoDriveHasReachedLocation()
{
	if (autoMode == Driving) {
		return (autoActionState == Completed);
	}

	return false;
}

void DriveSubsystem::AutoDriveReadMotorRotationCounts()
{
	autoDrivingParams.lastPositionReading[0] = fabs(cANTalon1->GetPosition());

	if (!AutoDriveUseOneMotorForDistanceDrive)
	{
		autoDrivingParams.lastPositionReading[1] = fabs(cANTalon2->GetPosition());
		autoDrivingParams.lastPositionReading[2] = fabs(cANTalon3->GetPosition());
		autoDrivingParams.lastPositionReading[3] = fabs(cANTalon4->GetPosition());
	}
}


AutoMode DriveSubsystem::AutoModeState() const
{
	return autoMode;
}

void DriveSubsystem::AutoModeDisable() {
	if (autoMode != Off) {
		if (autoMode == Driving)
		{
			// Cancel Driving
			if (autoActionState == InProgress)
			{
				SetMotorSpeeds(0.0);
			}
		}
		else if (autoMode == Rotating) {
			if (autoActionState == InProgress)
			{
				robotDrive->SetLeftRightMotorOutputs(0, 0);
			}
		}

		autoMode = Off;
		autoActionState = NotStarted;

		Logger::GetInstance()->Log(DriveSubsystemLogId,Logger::kINFO,"Auto Drive Mode DISABLED\n");
	}
	else {
		Logger::GetInstance()->Log(DriveSubsystemLogId,Logger::kINFO,"Auto Drive Mode ALREADY disabled,IGNNORING\n");
	}
}

bool DriveSubsystem::AutoRotateSetup(float angle, RotateDirection direction) {
	if (autoMode == Off) {
		if (!RotateDirectionValid(direction)) {
			Logger::GetInstance()->Log(DriveSubsystemLogId,Logger::kERROR,"Rotation direction invalid., Auto Rotation NOT enabled.\n");
			return false;
		}

		if (!InRangeInclusive(angle, 0, 180)) {
			Logger::GetInstance()->Log(DriveSubsystemLogId,Logger::kERROR,"Rotation angle outside of range, angle = %f, Auto Rotation NOT enabled. \n", angle);
			return false;
		}

		autoMode = Rotating;
		autoActionState = NotStarted;
		autoRotationParams.autoRotateInputAngle = angle;
		autoRotationParams.autoRotateDirection = direction;
		autoRotationParams.autoGyroTargetAngle = angle;

		if (direction == RotateLeft) {
			autoRotationParams.autoGyroTargetAngle += 180;
		}

		//here we need to reset the gyro
		gyro1->Reset();
		Logger::GetInstance()->Log(DriveSubsystemLogId,Logger::kINFO,"Auto Rotation Mode ENABLED, Direction = %s, InputAngle = %f, GyroTargetAngle = %f.\n",
								   RotateDirectionToString(autoRotationParams.autoRotateDirection).c_str(),
							       autoRotationParams.autoRotateInputAngle,
								   autoRotationParams.autoGyroTargetAngle);

		return true;
	}
	else {
		Logger::GetInstance()->Log(DriveSubsystemLogId,Logger::kERROR,"***Auto Mode ALREADY set to %s, IGNNORING***\n", AutoModeToString(autoMode).c_str());
	}

	return false;
}

static inline float NormalizeGyroAngle(float rawGyroAngle)
{
	static const int FullGyroSweep = 360 * static_cast<int>(AngleDecimalPlacesPrecision);

	rawGyroAngle *= AngleDecimalPlacesPrecision;
	rawGyroAngle = static_cast<float>((static_cast<int>(rawGyroAngle) % FullGyroSweep)) / AngleDecimalPlacesPrecision;

	return rawGyroAngle;
}

void DriveSubsystem::AutoRotateExecute()
{
	//RotateDirection being a new enum with just left and right
	// or we can find the shortest distance by comparing the
	if (autoMode == Rotating)
	{
		if (autoActionState == Completed)
		{
			return;
		}

		float currGyroAngle;

		if (!autoActionState == NotStarted) {
			// Indicate that the rotation is now in progress.
			autoActionState = InProgress;

			// Reset the gyro.
			gyro1->Reset();

			// First angle is 0 degress.
			currGyroAngle = 0.0;
		}
		else {
			currGyroAngle = NormalizeGyroAngle(gyro1->GetAngle());
		}

		AutoRotateMakeProgress(currGyroAngle);
	}
	else {
		Logger::GetInstance()->Log(DriveSubsystemLogId,Logger::kERROR,"***Auto Rotation not setup or already Rotating (%s), IGNNORING***\n", AutoModeToString(autoMode).c_str());
	}
}


bool DriveSubsystem::AutoHasFinishedRotating() {

	if (autoMode == Rotating) {
		return (autoActionState == Completed);
	}

	return false;
}

void DriveSubsystem::AutoRotateMakeProgress(float gyroAngle) {
	//RotateDirection being a new enum with just left and right
	// or we can find the shortest distance by comparing the
	if (autoMode == Rotating)
	{
		if (autoActionState == InProgress)
		{
			float distanceFromGoal = autoRotationParams.autoGyroTargetAngle - gyroAngle;

			if (!DistanceWithinEpsilon(distanceFromGoal, AutoRotate_TargetAngle_Epsilon))
			{
				// Calculate the speed that the Robot should start rotating at.
				float percentageOfMaxSpeed = CalcPercentageOfMaxSpeed(fabs(distanceFromGoal),
																	  fabs(autoRotationParams.autoGyroTargetAngle),
																	  AutoRotateSlowDownThreshold);

				float absoluteRotationSpeed = AutoRotateMaxSpeed * percentageOfMaxSpeed;

				// Over shot the target, change the rotation to left.
				if (distanceFromGoal < 0.0)
				{
					autoRotationParams.autoRotateDirection = RotateLeft;
				}
				else
				{
					autoRotationParams.autoRotateDirection = RotateRight;
				}

				switch (autoRotationParams.autoRotateDirection)
				{
					case RotateLeft:
					robotDrive->SetLeftRightMotorOutputs(-absoluteRotationSpeed, absoluteRotationSpeed);
					break;

					case RotateRight:
					robotDrive->SetLeftRightMotorOutputs(absoluteRotationSpeed, -absoluteRotationSpeed); //i would implement a system to slow it down when it gets near the destination angle
					break;

					default:
					robotDrive->SetLeftRightMotorOutputs(0, 0);
					autoActionState = Completed;
					//insert logging statement here
					break;
				}
			}
			else {
				// Hit the stopping point, shutdown.
				robotDrive->SetLeftRightMotorOutputs(0, 0);
				autoActionState = Completed;
			}
		}
	}
	else {
		Logger::GetInstance()->Log(DriveSubsystemLogId,Logger::kERROR,"***Auto Rotation not setup or already Rotating (%s), IGNNORING***\n", AutoModeToString(autoMode).c_str());
	}
}


// Use a sin-wave based function to compute the slow-down trajectory percentage
// as the robot approaches its goal.
static double CalcPercentageOfMaxSpeed(double absoluteDistanceFromGoal,
									   double absoluteGoalDistance,
									   double absoluteSlowDownThresholdDistance)
{
	// If the current distance from the goal is more than the distance that
	// should cause the Robot to start slowing down then run it at 100%
    if (absoluteDistanceFromGoal >= absoluteSlowDownThresholdDistance)
    {
        return 1.0;
    }
    else
    {
        double sinoidal = sin((M_PI / 2.0) * (absoluteDistanceFromGoal / absoluteGoalDistance));

        return sinoidal;
    }
}

void DriveSubsystem::SetMotorSpeeds(float frontLeftMotorSpeed,
									float rearLeftMotorSpeed,
									float frontRightMotorSpeed,
									float rearRightMotorSpeed) {
	cANTalon1->Set(frontLeftMotorSpeed);
	cANTalon4->Set(rearRightMotorSpeed);
	cANTalon2->Set(rearLeftMotorSpeed);
	cANTalon3->Set(frontRightMotorSpeed);
}

void DriveSubsystem::SetMotorSpeeds(float speed)
{
	cANTalon1->Set(speed);
	cANTalon4->Set(speed);
	cANTalon2->Set(speed);
	cANTalon3->Set(speed);
}




