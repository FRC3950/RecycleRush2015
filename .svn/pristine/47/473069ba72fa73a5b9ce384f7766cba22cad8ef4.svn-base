// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.




#include "DriveSubsystem.h"

#include "../RobotMap.h"
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include "../Commands/DriveCommand.h"
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

#include "../UtilFun.h"
#include "../Logger.h"
#include "../LoggingComponentDefs.h"
#include "../ConfigKeys.h"
#include "../Config/ConfigInstanceMgr.h"

static const float TWIST_TOLERANCE_MIN_DEFAULT = -0.33;
static const float TWIST_TOLERANCE_MAX_DEFAULT = 0.33;
static const float TWIST_SCALE_FACTOR_DEFAULT = 0.65;

static const float Y_TOLERANCE_MIN_DEFAULT = -0.25;
static const float Y_TOLERANCE_MAX_DEFAULT = 0.25;

static const float X_TOLERANCE_MIN_DEFAULT = -0.25;
static const float X_TOLERANCE_MAX_DEFAULT = 0.35;

static bool Drive_Params_Inited = false;

static float Twist_Tolerance_Min = -0.33;
static float Twist_Tolerance_Max = 0.33;
static float Twist_Scale_Factor = 0.65;

static float Y_Tolerance_Min = -0.25;
static float Y_Tolerance_Max = 0.25;

static float X_Tolerance_Min = -0.25;
static float X_Tolerance_Max = 0.35;

static const bool DRIVE_SAFETY_ENABLED_DEFAULT = false;
static const float DRIVE_SAFETY_TIME_OUT_DEFAULT = 1.0;

static const std::string forwardHeading = "Forward";
static const std::string BackHeading = "Back";
static const std::string LeftHeading = "Left";
static const std::string RightHeading = "Right";
static const std::string IllegalHeading = "Illegal Heading";

static const std::string& DriveHeadingToString(DriveHeading heading){
	switch (heading) {
	case Forward:
		return forwardHeading;

	case Back:
		return BackHeading;

	case Left:
		return LeftHeading;

	case Right:
		return RightHeading;

	default:
		return IllegalHeading;
	}

}

static const bool DriveHeadingValid(DriveHeading heading){
	switch (heading) {
	case Forward:
	case Back:
	case Left:
	case Right:
		return true;

	default:
		return false;
	}

}

// *********************************************************************************
// V a r i o u s  M o d e s  of the  T a l o n   M o t o r
// This sets the mode of the m_motor. The options are:
// kPercentVbus: basic throttle; no closed-loop.
// kCurrent: Runs the motor with the specified current if possible.
// kSpeed: Runs a PID control loop to keep the motor going at a constant
//   speed using the specified sensor.
// kPosition: Runs a PID control loop to move the motor to a specified move
//   the motor to a specified sensor position.
// kVoltage: Runs the m_motor at a constant voltage, if possible.
// kFollower: The m_motor will run at the same throttle as the specified other talon.
//m_motor.SetControlMode(CANSpeedController::kPosition);
// This command allows you to specify which feedback device to use when doing
// closed-loop control. The options are:
// AnalogPot: Basic analog potentiometer
// QuadEncoder: Quadrature Encoder
// AnalogEncoder: Analog Encoder
// EncRising: Counts the rising edges of the QuadA pin (allows use of a
//   non-quadrature encoder)
// EncFalling: Same as EncRising, but counts on falling edges.
// m_motor.SetFeedbackDevice(CANTalon::AnalogPot);
// This sets the basic P, I , and D values (F, Izone, and rampRate can also
//   be set, but are ignored here).
// These must all be positive floating point numbers (SetSensorDirection will
//   multiply the sensor values by negative one in case your sensor is flipped
//   relative to your motor).
// These values are in units of throttle / sensor_units where throttle ranges
//   from -1023 to +1023 and sensor units are from 0 - 1023 for analog
//   potentiometers, encoder ticks for encoders, and position / 10ms for
//   speeds.
// m_motor.SetPID(1.0, 0.0, 0.0);
// *********************************************************************************

DriveSubsystem::DriveSubsystem() : Subsystem("DriveSubsystem") {
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	cANTalon1 = RobotMap::driveSubsystemCANTalon1;
	cANTalon3 = RobotMap::driveSubsystemCANTalon3;
	cANTalon2 = RobotMap::driveSubsystemCANTalon2;
	cANTalon4 = RobotMap::driveSubsystemCANTalon4;
	robotDrive = RobotMap::driveSubsystemRobotDrive;
	gyro1 = RobotMap::driveSubsystemGyro1;
	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	autoEnabled = false;
	autoDriving = false;
	autoHeading = Forward;
	autoDriveDistenceInInches = 0;


    ConfigMgr *configMgr = ConfigInstanceMgr::getInstance();
    if (!Drive_Params_Inited) {
    	X_Tolerance_Min = configMgr->getDoubleVal(ConfigKeys::Drive_XToleranceMin,X_TOLERANCE_MIN_DEFAULT);

    	X_Tolerance_Max = configMgr->getDoubleVal(ConfigKeys::Drive_XToleranceMax,X_TOLERANCE_MAX_DEFAULT);

    	Y_Tolerance_Min = configMgr->getDoubleVal(ConfigKeys::Drive_YToleranceMin,Y_TOLERANCE_MIN_DEFAULT);

    	Y_Tolerance_Max = configMgr->getDoubleVal(ConfigKeys::Drive_YToleranceMax,Y_TOLERANCE_MAX_DEFAULT);

    	Twist_Tolerance_Min = configMgr->getDoubleVal(ConfigKeys::Drive_TwistToleranceMin,TWIST_TOLERANCE_MIN_DEFAULT);

    	Twist_Tolerance_Max = configMgr->getDoubleVal(ConfigKeys::Drive_TwistToleranceMax,TWIST_TOLERANCE_MAX_DEFAULT);

    	Twist_Scale_Factor = configMgr->getDoubleVal(ConfigKeys::Drive_TwistScaleFactor,TWIST_SCALE_FACTOR_DEFAULT);

    	Logger::GetInstance()->Log(DriveSubsystemLogId,Logger::kINFO, "DriveSubsystem: X Tolerance min = %f, max = %f\n", X_Tolerance_Min, X_Tolerance_Max);
    	Logger::GetInstance()->Log(DriveSubsystemLogId,Logger::kINFO, "DriveSubsystem: Y Tolerance min = %f, max = %f\n", Y_Tolerance_Min, Y_Tolerance_Max);
    	Logger::GetInstance()->Log(DriveSubsystemLogId,Logger::kINFO, "DriveSubsystem: Twist Tolerance min = %f, max = %f, Scale factor = %f \n", Twist_Tolerance_Min, Twist_Tolerance_Max, Twist_Scale_Factor);

    	Drive_Params_Inited = true;
    }

	if (gyro1)
	{
	    useGyro = configMgr->getBoolVal(ConfigKeys::Drive_UseGyroKey, DriveSubsystemConfigValueDefaults::Drive_UseGyroDefaultValue);
	}
	else
	{
		useGyro = false;
	}

	cANTalon1->SetControlMode(CANTalon::kPercentVbus);
	cANTalon3->SetControlMode(CANTalon::kPercentVbus);
	cANTalon2->SetControlMode(CANTalon::kPercentVbus);
	cANTalon4->SetControlMode(CANTalon::kPercentVbus);
}
    
void DriveSubsystem::InitDefaultCommand() {
	// Set the default command for a subsystem here.
	//SetDefaultCommand(new MySpecialCommand());
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	SetDefaultCommand(new DriveCommand());
	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}


// Put methods for controlling this subsystem
// here. Call these from Commands.

void DriveSubsystem::MecanumDrive(float x, float y, float twist) {
	float gyroAngle = 0.0;

	// Only attempt to use the gyro if it has been created
	// and the configuration says to use it.
	if (gyro1 && useGyro)
	{
		gyroAngle = gyro1->GetAngle();
	}

	//filter the X Y and twist values to 0 if they are in a min max tolerence range
	// otherwise the original value is used

	x = ZeroIfInRangeInclusive(x, X_Tolerance_Min,X_Tolerance_Max);
	y = ZeroIfInRangeInclusive(y,Y_Tolerance_Min,Y_Tolerance_Max);
	twist = ZeroIfInRangeInclusive(twist,Twist_Tolerance_Min,Twist_Tolerance_Max);

	//Scale twist so movements are smoother.
	twist *= Twist_Scale_Factor;

	Logger::GetInstance()->Log(DriveSubsystemLogId,Logger::kINFO, "DriveSubsystem:Filtered(x,y,twist,angle)=(%f, %f, %f, %f)\n", x, y, twist, gyroAngle);

	robotDrive->MecanumDrive_Cartesian(x, y, twist, gyroAngle);

	//robotDriveMecanum->ArcadeDrive(y,twist);
}

void DriveSubsystem::EnableDriveSubsystem() {
	 ConfigMgr *configMgr = ConfigInstanceMgr::getInstance();

	 float expiration = 0.0;
	 bool enable = configMgr->getBoolVal(ConfigKeys::Drive_EnableSafety, DRIVE_SAFETY_ENABLED_DEFAULT);

	 if (enable)
	 {
		 expiration = configMgr->getDoubleVal(ConfigKeys::Drive_SafetyTimeOut, DRIVE_SAFETY_TIME_OUT_DEFAULT);
	 }

	Logger::GetInstance()->Log(DriveSubsystemLogId,Logger::kINFO, "DriveSubsystem:EnableDriveSubsystem() ->SafetyEnable=%s, timeout=%f\n",
			enable ? "TRUE" : "FALSE",
			expiration);

	SetSafetyMode(cANTalon1, enable, expiration);
	SetSafetyMode(cANTalon2, enable, expiration);
	SetSafetyMode(cANTalon3, enable, expiration);
	SetSafetyMode(cANTalon4, enable, expiration);
	robotDrive->SetSafetyEnabled(enable);

	if (enable)
	{
		robotDrive->SetSafetyEnabled(expiration);
	}

	cANTalon1->EnableControl();
	cANTalon2->EnableControl();
	cANTalon3->EnableControl();
	cANTalon4->EnableControl();


	cANTalon1->Set(0);
	cANTalon2->Set(0);
	cANTalon3->Set(0);
	cANTalon4->Set(0);
}

void DriveSubsystem::SetSafetyMode(CANTalon* motor, bool enabled, float timeout) {
	motor->SetSafetyEnabled(enabled);
	motor->SetExpiration(timeout);
}

bool DriveSubsystem::AutoModeSetup(DriveHeading heading, float distance)
{
	if (!autoEnabled) {
		if (DriveHeadingValid(heading) && (autoDriveDistenceInInches > 0.0))
		{
			autoDriving = false;
			autoHeading = heading;
			autoDriveDistenceInInches = distance;
			autoEnabled = true;
			Logger::GetInstance()->Log(DriveSubsystemLogId,Logger::kINFO,"Auto Drive Mode ENABLED, heading = %s, distance = %f inches \n", DriveHeadingToString(autoHeading).c_str(), autoDriveDistenceInInches);
			return true;
		}
		else{
			Logger::GetInstance()->Log(DriveSubsystemLogId,Logger::kERROR,"Auto Drive Mode NOT ENABLED, illegal heading = %s or distance = %f inches \n", DriveHeadingToString(autoHeading).c_str(), autoDriveDistenceInInches);
		}
	}
	else {
		Logger::GetInstance()->Log(DriveSubsystemLogId,Logger::kERROR,"***Auto Drive Mode ALREADY Enabled, IGNNORING***\n");
	}
	return false;
}

void DriveSubsystem::AutoMoveExecute()
{
	if (autoEnabled && !autoDriving) {
		autoDriving = true;
		// here is where we would start the PID or the manual encoder code
	}
	else {
		Logger::GetInstance()->Log(DriveSubsystemLogId,Logger::kERROR,"***Auto Driving not setup or already Auto Driving, IGNNORING***\n");
	}
}

bool DriveSubsystem::AutoAreWeThereYet()
{
	if (autoEnabled && autoDriving){
		autoEnabled = false;
		autoDriving = false;
		return true;
	}
	return false;
}

bool DriveSubsystem::AutoEnabled() const
{
	return autoEnabled;
}

void DriveSubsystem::AutoModeDisable(){
	if (autoEnabled) {
		autoEnabled = false;
		Logger::GetInstance()->Log(DriveSubsystemLogId,Logger::kINFO,"Auto Drive Mode DISABLED\n");
	}
	else {
		Logger::GetInstance()->Log(DriveSubsystemLogId,Logger::kINFO,"Auto Drive Mode ALREADY disabled,IGNNORING\n");
	}
}

