// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.




#include "DriveSubsystem.h"
#include "../RobotMap.h"
// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES
#include "../Commands/DriveCommand.h"
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INCLUDES

#include "../UtilFun.h"
#include "../Logger.h"
#include "../LoggingComponentDefs.h"

// *********************************************************************************
// V a r i o u s  M o d e s  of the  T a l o n   M o t o r
// This sets the mode of the m_motor. The options are:
// kPercentVbus: basic throttle; no closed-loop.
// kCurrent: Runs the motor with the specified current if possible.
// kSpeed: Runs a PID control loop to keep the motor going at a constant
//   speed using the specified sensor.
// kPosition: Runs a PID control loop to move the motor to a specified move
//   the motor to a specified sensor position.
// kVoltage: Runs the m_motor at a constant voltage, if possible.
// kFollower: The m_motor will run at the same throttle as the specified other talon.
//m_motor.SetControlMode(CANSpeedController::kPosition);
// This command allows you to specify which feedback device to use when doing
// closed-loop control. The options are:
// AnalogPot: Basic analog potentiometer
// QuadEncoder: Quadrature Encoder
// AnalogEncoder: Analog Encoder
// EncRising: Counts the rising edges of the QuadA pin (allows use of a
//   non-quadrature encoder)
// EncFalling: Same as EncRising, but counts on falling edges.
// m_motor.SetFeedbackDevice(CANTalon::AnalogPot);
// This sets the basic P, I , and D values (F, Izone, and rampRate can also
//   be set, but are ignored here).
// These must all be positive floating point numbers (SetSensorDirection will
//   multiply the sensor values by negative one in case your sensor is flipped
//   relative to your motor).
// These values are in units of throttle / sensor_units where throttle ranges
//   from -1023 to +1023 and sensor units are from 0 - 1023 for analog
//   potentiometers, encoder ticks for encoders, and position / 10ms for
//   speeds.
// m_motor.SetPID(1.0, 0.0, 0.0);
// *********************************************************************************

DriveSubsystem::DriveSubsystem() : Subsystem("DriveSubsystem") {
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
	cANTalon0 = RobotMap::driveSubsystemCANTalon0;
	cANTalon1 = RobotMap::driveSubsystemCANTalon1;
	cANTalon2 = RobotMap::driveSubsystemCANTalon2;
	cANTalon3 = RobotMap::driveSubsystemCANTalon3;
	robotDrive = RobotMap::driveSubsystemRobotDrive;
	gyro1 = RobotMap::driveSubsystemGyro1;
	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS


	cANTalon0->SetControlMode(CANTalon::kPercentVbus);
	cANTalon1->SetControlMode(CANTalon::kPercentVbus);
	cANTalon2->SetControlMode(CANTalon::kPercentVbus);
	cANTalon3->SetControlMode(CANTalon::kPercentVbus);


}
    
void DriveSubsystem::InitDefaultCommand() {
	// Set the default command for a subsystem here.
	//SetDefaultCommand(new MySpecialCommand());
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	SetDefaultCommand(new DriveCommand());
	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
}


// Put methods for controlling this subsystem
// here. Call these from Commands.
static const float TWIST_TOLERANCE_MIN = -0.33;
static const float TWIST_TOLERANCE_MAX = 0.33;
static const float TWIST_SCALE_FACTOR = 0.65;

static const float Y_TOLERANCE_MIN = -0.25;
static const float Y_TOLERANCE_MAX = 0.25;

static const float X_TOLERANCE_MIN = -0.25;
static const float X_TOLERANCE_MAX = 0.35;

void DriveSubsystem::MecanumDrive(float x, float y, float twist) {
	float gyroAngle = gyro1->GetAngle(); // uncomment when you want to use the gyro//

	//printf("DriveSubsystem:(x,y,twist,angle)=(%f, %f, %f, %f)\n", x, y, twist, gyroAngle);
	//filter the X Y and twist values to 0 if they are in a min max tolerence range
	// otherwise the original value is used
	x = ZeroIfInRangeInclusive(x, X_TOLERANCE_MIN, X_TOLERANCE_MAX);
	y = ZeroIfInRangeInclusive(y, Y_TOLERANCE_MIN, Y_TOLERANCE_MAX);
	twist = ZeroIfInRangeInclusive(twist, TWIST_TOLERANCE_MIN, TWIST_TOLERANCE_MAX);

	//Scale twist so movements are smoother.
	twist *= TWIST_SCALE_FACTOR;

	//Uncomment this if you want to disable the gyro.
	//gyroAngle = 0.0;

	Logger::GetInstance()->Log(DriveSubsystemLogId,Logger::kINFO, "DriveSubsystem:Filtered(x,y,twist,angle)=(%f, %f, %f, %f)\n", x, y, twist, gyroAngle);

	robotDrive->MecanumDrive_Cartesian(x, y, twist, gyroAngle);

	//robotDriveMecanum->ArcadeDrive(y,twist);
}

