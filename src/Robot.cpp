// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "Robot.h"

#include "Logger.h"
#include "LoggingComponentDefs.h"
#include "Commands/Autonomous_1CS2_Command.h"
#include "Commands/Autonomous_1RS_Command.h"
#include "Commands/Autonomous_1TS_Command.h"
#include "Commands/Autonomous_3SS_Command.h"
#include "Commands/Autonomous_1TSS_Command.h"
#include "Commands/Autonomous_Do_Nothing_Command.h"
#include "Config/CsvConfigFileReader.h"
#include "Config/ConfigInstanceMgr.h"

static const std::string ConfigFileName = "/home/lvuser/RobotConfig.csv";

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INITIALIZATION
GantrySubsystem* Robot::gantrySubsystem = 0;
DriveSubsystem* Robot::driveSubsystem = 0;
OI* Robot::oi = 0;
// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INITIALIZATION

Robot::Robot()
	: autonomousCommand(NULL),
	  lw(NULL),
	  autonomousChooser(NULL),
	  lastTimeCompressorDisplayed(0.0),
	  skipDisableModeActions(false)
{
	Logger *logger = Logger::GetInstance(true, true);
	// Change level as per your debugging needs.
	logger->SetLoggingMask(DefaultLoggingMask);
	logger->SetLoggingLevel(DefaultLoggingLevel);
	logger->Log(RobotLogId, Logger::kINFO, "Robot class constructor!");
	logger->Log(DriveSubsystemLogId, Logger::kINFO, "Drive Subsystem test.");
	ConfigInstanceMgr::getInstance(ConfigFileName, false);
}

void Robot::RobotInit() {
	Logger *logger = Logger::GetInstance();
	logger->Log(RobotLogId, Logger::kINFO, "RobotInit() -> Entered\n");
	RobotMap::init();
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS

#if 1

	gantrySubsystem = new GantrySubsystem();

#endif

	driveSubsystem = new DriveSubsystem();
	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
	// This MUST be here. If the OI creates Commands (which it very likely
	// will), constructing it during the construction of CommandBase (from
	// which commands extend), subsystems are not guaranteed to be
	// yet. Thus, their requires() statements may grab null pointers. Bad
	// news. Don't move it.
	oi = new OI();
	lw = LiveWindow::GetInstance();

	autonomousChooser = new SendableChooser();
	autonomousChooser->AddDefault("Do Nothing", new Autonomous_Do_Nothing_Command());
	autonomousChooser->AddObject("Can/Robot set", new Autonomous_1RS_Command());
	autonomousChooser->AddObject("Can/Tote set", new Autonomous_1TS_Command());
	autonomousChooser->AddObject("stack set", new Autonomous_3SS_Command());
	autonomousChooser->AddObject("Do not use this one", new Autonomous_1CS2_Command());
	autonomousChooser->AddObject("Can/Tote set but stay in one place", new Autonomous_1TSS_Command());


	SmartDashboard::PutData("Autonomous Modes", autonomousChooser);
	ShowCompressorState(true);
	skipDisableModeActions = false;
	// instantiate the command used for the autonomous period
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
	// END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
  }

/**
 * This function is called when the disabled button is hit.
 * You can use it to reset subsystems before shutting down.
 */
void Robot::DisabledInit(){
	Logger *logger = Logger::GetInstance();
	logger->Log(RobotLogId, Logger::kINFO, "DisabledInit() -> Entered\n");

	// Only perform the following actions if not skipping in disable mode.
	// Skipping is only true when the Robot has entered autonomous mode
	// and is now transitioning through disable mode potentially on its
	// way to teleop mode.
	if (!skiDisableModeActions)
	{
		// Make sure the lift subsystem starts in the down position when
		// the robot is enabled the next time.
		gantrySubsystem->FireLiftSolenoid(false);
	}

	// Set back to skip so that the next time through the actions
	// will be taken.
	skipDisableModeActions = false;

	ShowCompressorState(true);
}

void Robot::DisabledPeriodic() {
	Scheduler::GetInstance()->Run();
	ShowCompressorState(false);
}

void Robot::AutonomousInit() {
	Logger *logger = Logger::GetInstance();
	logger->Log(RobotLogId, Logger::kINFO, "AutonomousInit() -> Entered\n");

	// Set the skip disable mode actions flag to true so that if the
	// Robot goes into Teleop mode next, anything that was setup by
	// autonomous that shouldn't be typically reset won't be.
	skipDisableModeActions = true;

	driveSubsystem->EnableDriveSubsystem();
	autonomousCommand = static_cast<Command *>(autonomousChooser->GetSelected());

	if (autonomousCommand != NULL)
	{
		autonomousCommand->Start();
	}
}

void Robot::AutonomousPeriodic() {
	ShowCompressorState(false);
	Scheduler::GetInstance()->Run();
}

void Robot::TeleopInit() {
	Logger *logger = Logger::GetInstance();
	logger->Log(RobotLogId, Logger::kINFO, "TeleopInit() -> Entered\n");
	// This makes sure that the autonomous stops running when
	// teleop starts running. If you want the autonomous to 
	// continue until interrupted by another command, remove
	// these lines or comment it out.

	if (autonomousCommand != NULL)
		autonomousCommand->Cancel();

	driveSubsystem->EnableDriveSubsystem();
}

void Robot::TeleopPeriodic() {
	ShowCompressorState(false);
	//SmartDashboard::PutNumber("Pressure",(double)ConvertVoltsToPSI(RobotMap::transduser->GetVoltage()));
	Scheduler::GetInstance()->Run();
}

void Robot::TestPeriodic() {

	lw->Run();
}

static const double COMPRESSOR_DISPLAY_DELAY_TIME = 1.0;

void Robot::ShowCompressorState(bool forcedUpdate) {
	double curTime = Timer::GetFPGATimestamp();

	if (forcedUpdate || ((curTime - lastTimeCompressorDisplayed) >= COMPRESSOR_DISPLAY_DELAY_TIME)) {
		SmartDashboard::PutBoolean("compressor state",RobotMap::compressor->Enabled());
		lastTimeCompressorDisplayed = curTime;
	}
}
float Robot::ConvertVoltsToPSI(float V){
		float PSI = ((48*V) - 24);
		return PSI;
	}


START_ROBOT_CLASS(Robot);
